<?php
// 不同进制表示
$decimal = 1234;
$octal = 0123;      // 八进制
$hex = 0x1A;        // 十六进制
$binary = 0b11111111; // 二进制

// 整数溢出（64位系统）
$large = PHP_INT_MAX;
$overflow = $large + 1; // 自动转为float

var_dump(PHP_INT_SIZE); // 查看整数字节数

// 注意事项
$calc = (int) ( (0.1 + 0.7) * 10 ); // 结果为7，不是8！
?>

<!-- 
为什么 (0.1 + 0.7) * 10 结果是 7 而不是 8？

1. 浮点数的二进制表示问题

计算机用 二进制 存储浮点数（如 0.1, 0.7），但某些十进制小数无法精确表示为二进制，导致 微小的精度丢失。

• 0.1 的二进制表示是 0.000110011001100110011001100...（无限循环）

• 0.7 的二进制表示是 0.101100110011001100110011...（无限循环）

2. 实际计算过程

当计算 (0.1 + 0.7) * 10 时：
1. 0.1 + 0.7 的 真实结果 不是 0.8，而是一个接近 0.8 的近似值（如 0.7999999999999999）。
2. 乘以 10 后得到 7.999999999999999。
3. 用 (int) 强制转换为整数时，PHP 会 直接截断小数部分（不是四舍五入），得到 7。

如何解决？

方法 1：使用 round() 四舍五入

$calc = (int) round((0.1 + 0.7) * 10);  // 结果为 8


方法 2：改用整数运算（避免浮点数）

$calc = (1 + 7) * 1;  // 用整数计算，完全避免浮点问题


方法 3：使用高精度数学函数（bcmath 扩展）

$sum = bcadd('0.1', '0.7', 1);  // 0.8
$calc = (int) bcmul($sum, '10', 0);  // 8

需要先安装 bcmath：
sudo apt install php-bcmath  # Ubuntu/Debian


方法 4：比较时容忍误差（不强制转换）

$result = (0.1 + 0.7) * 10;
if (abs($result - 8) < 0.00001) {
    echo "可以视为 8";
}


关键点总结

问题 原因 解决方案

(0.1 + 0.7) * 10 等于 7 浮点数二进制存储不精确 + 强制截断转换 1. 用 round() 四舍五入<br>2. 改用整数运算<br>3. 使用 bcmath 高精度计算

为什么其他语言也有类似问题？

• IEEE 754 标准：大多数编程语言遵循该标准表示浮点数，均存在此问题。

• 示例（JavaScript）：
  console.log(0.1 + 0.2);  // 输出 0.30000000000000004
  

最佳实践

1. 金融计算等敏感场景：  
   使用 bcmath 或专用库（如 PHP 的 moontoast/math）。
2. 一般场景：  
   用 round() 或比较时容忍微小误差。
3. 避免直接 (int) 转换浮点数：  
   优先四舍五入或整数化处理。

理解这一点后，你的代码会更健壮！ 🚀 -->