`go build` 和 `go run` 的区别以及它们的底层原理。

### 一句话总结

*   **`go run`**: 是一个**编译并立即执行**的快捷命令。它为了“跑一下看看结果”，编译后的可执行文件是临时的，运行结束后通常会被删除。
*   **`go build`**: 是一个**编译并生成可执行文件**的命令。它为了“构建一个可以分发或部署的二进制程序”，编译后的文件会保留在当前目录或指定路径。

---

### 详细区别对比

| 特性 | `go run` | `go build` |
| :--- | :--- | :--- |
| **主要目的** | 快速编译并执行，用于开发阶段测试 | 编译代码，生成可执行文件，用于生产部署 |
| **输出产物** | **不生成**可执行文件（或生成在临时目录并自动删除） | **生成**可执行文件（默认与包名相同，可用 `-o` 指定） |
| **文件留存** | 可执行文件是临时的，运行结束后被清理 | 可执行文件永久留存，可复制、分发 |
| **常用场景** | 开发调试，快速验证代码逻辑 | 构建用于测试、预生产或生产的二进制包 |
| **处理多个文件** | 必须指定所有主要的 `.go` 文件，如 `go run main.go utils.go` | 只需指定包路径，如 `go build .`，工具会自动解析依赖 |
| **性能影响** | 每次运行都需重新编译，对于大项目启动稍慢 | 编译一次，可重复无限次执行，启动速度快 |

---

### 底层原理深度解析

要理解它们的区别，最关键的是了解 Go 的编译过程和这两个命令在流程上的细微差异。

#### Go 的编译流程（共性强）

无论是 `go build` 还是 `go run`，它们都共享了绝大部分的编译过程。这个过程大致如下：

1.  **词法与语法分析**
    *   将源代码转换为一系列的 Token（词元）。
    *   然后将 Token 序列化为抽象的语法结构——**抽象语法树（AST）**。

2.  **类型检查与语义分析**
    *   遍历 AST，进行类型推导和校验，确保程序的类型安全性（例如，函数调用参数是否匹配）。
    *   进行函数内联等初步优化决策。

3.  **中间代码生成（SSA）**
    *   将类型检查后的 AST 转换为一种称为**静态单赋值形式（SSA）** 的中间表示。
    *   在 SSA 阶段，编译器会进行大量**高级优化**，如死代码消除、边界检查消除、常量传播等。这是现代编译器性能优化的核心环节。

4.  **机器码生成**
    *   将优化后的 SSA 中间代码转换为特定目标平台（如 Linux x86-64, Windows arm64）的**机器码（.o 文件）**。

5.  **链接**
    *   将生成的所有机器码对象文件（.o）、依赖的静态库、运行时（runtime）等**链接**成一个完整的、可执行的文件。
    *   Go 的一个重要特性是，它的运行时（包括垃圾收集器、调度器等）和所有依赖库都会**静态链接**到这个最终的可执行文件中。这就是为什么 Go 程序生成的是一个巨大的、但可以独立部署的二进制文件的原因。

#### `go build` 的独特点

*   **执行上述完整的 1-5 步**。
*   在第5步**链接**完成后，它将最终的可执行文件**写入到当前目录**（或 `-o` 指定的路径）。
*   整个过程结束，命令退出。

#### `go run` 的独特点

*   **执行上述第 1 到第 4 步**，生成机器码对象文件（.o）。
*   它**也会执行第5步链接**，生成一个完整的可执行文件。但是！
*   它**不会**将这个可执行文件输出到你的当前工作目录。而是将其**写入操作系统的临时目录**（例如 Linux 下的 `/tmp`）。
*   然后，命令**fork/exec**（ fork 出一个新进程并执行）这个临时目录下的可执行文件。
*   当你的程序执行完毕后（无论是正常退出还是崩溃），`go run` 命令会**自动清理并删除**这个临时生成的可执行文件。

这就是为什么你用 `go run` 之后看不到.exe或可执行文件，但实际上完整的编译和链接过程都已经发生了。

### 如何验证？

你可以使用 `-work` 参数来让 `go run` 告诉你它把临时文件放在了哪里，并且运行后不删除它们。

```bash
$ go run -work main.go
WORK=/var/folders/.../some-random-temp-dir
Hello, World!
```

这时，你可以进入它输出的那个临时目录，会发现里面已经生成了完整的可执行文件。这证明了 `go run` 确实经历了完整的编译和链接过程。

### 总结与类比

| 命令 | 类比 |
| :--- | :--- |
| `go run main.go` | 类似于在脚本语言中 `python main.py`。但注意，Go 是先编译再执行，而 Python 是解释执行。 |
| `go build -o myapp && ./myapp` | 类似于 C++ 中的 `g++ main.cpp -o myapp && ./myapp`。 |

**结论：**
`go run` 在底层可以看作是 `go build` + 将输出文件放到临时目录 + 执行临时文件 + 清理临时文件 的一个组合命令。它的设计初衷是为了提升开发者的体验，让测试代码变得像运行脚本一样简单，但其背后依然是 Go 语言强大的静态编译工具链。